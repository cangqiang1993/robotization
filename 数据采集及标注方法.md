## 1.数据采集方法

### 1.1 屏幕截图采集

```
# 使用OBS或Python自动截图示例
import pyautogui
import time

for i in range(1000):  # 采集1000张样本
    screenshot = pyautogui.screenshot()
    timestamp = int(time.time())
    screenshot.save(f"data/dataset/images/train/game_{timestamp}.png")
    time.sleep(0.5)  # 每0.5秒采集一张
```

### 1.2 视频分解采集

```
# 使用FFmpeg将预录视频分解为帧
ffmpeg -i data/recordings/gameplay.mp4 -r 2 data/dataset/images/train/frame_%04d.png
# -r 2 表示每秒提取2帧
```



## 2. 标注工具选择

### 2.1 推荐标注工具

 **LabelImg** (图形界面) 

```
pip install labelImg
labelImg  # 启动
```

### 2.2 使用教程：

####  配置游戏目标类别

1. 创建 `data/classes.txt` 文件，内容与您的 `game_data.yaml` 一致：

   ```
   monster_normal
   monster_elite
   monster_boss
   npc_friendly
   ui_button
   item_health
   item_mana
   minimap_marker
   ```

2. 在LabelImg中加载类别文件：

   - 点击菜单栏 `View` → `Auto Save Mode`（开启自动保存）
   - `File` → `Change Save Dir` 设置为 `data/dataset/labels/train/`
   - `Open Dir` 选择 `data/dataset/images/train/`

**CVAT** (在线高级工具) 

- https://github.com/openvinotoolkit/cvat
- 适合团队协作标注

 **Roboflow** (在线服务) 

- https://roboflow.com/
- 提供自动标注辅助功能

### 2.2 标注流程示例

1. 打开LabelImg
2. 设置标注格式为YOLO
3. 打开`data/dataset/images/train/`目录
4. 对每个目标画框并选择类别
5. 保存后会自动生成同名的.txt标注文件

## 3. 标注文件格式详解

 每个图像对应一个.txt文件，例如`game_1234.png`对应`game_1234.txt` 

```
0 0.5 0.5 0.2 0.3  # 类别0 中心(50%,50%) 宽20% 高30%
1 0.3 0.7 0.1 0.1  # 类别1 中心(30%,70%) 宽10% 高10%
```

 格式说明： 

```
<class_id> <x_center> <y_center> <width> <height>
```

- 所有值都是相对于图像宽高的比例(0-1)
- 每行一个目标

## 4. 自动化标注辅助

### 4.1 使用预训练模型辅助标注

    # 使用现有模型生成初步标注
    from src.detector import YOLODetector
    
    detector = YOLODetector(config)
    for img_path in Path("data/dataset/images/train").glob("*.png"):
        image = cv2.imread(str(img_path))
        detections = detector.detect(image)
        
        with open(f"data/dataset/labels/train/{img_path.stem}.txt", "w") as f:
            for det in detections:
                x1, y1, x2, y2 = det['bbox']
                width = (x2 - x1) / image.shape[1]
                height = (y2 - y1) / image.shape[0]
                x_center = (x1 + x2) / 2 / image.shape[1]
                y_center = (y1 + y2) / 2 / image.shape[0]
                f.write(f"{det['class_id']} {x_center} {y_center} {width} {height}\n")
### 4.2 数据增强生成更多样本

```
# 使用albumentations进行数据增强
import albumentations as A

transform = A.Compose([
    A.HorizontalFlip(p=0.5),
    A.RandomBrightnessContrast(p=0.2),
    A.Blur(p=0.1),
], bbox_params=A.BboxParams(format='yolo'))

for img_path in Path("data/dataset/images/train").glob("*.png"):
    image = cv2.imread(str(img_path))
    label_path = f"data/dataset/labels/train/{img_path.stem}.txt"
    
    # 读取标注
    with open(label_path) as f:
        bboxes = []
        class_ids = []
        for line in f:
            class_id, xc, yc, w, h = map(float, line.split())
            bboxes.append([xc, yc, w, h])
            class_ids.append(class_id)
    
    # 应用增强
    transformed = transform(image=image, bboxes=bboxes, class_ids=class_ids)
    cv2.imwrite(f"aug_{img_path.name}", transformed['image'])
    
    # 保存增强后的标注
    with open(f"aug_{img_path.stem}.txt", "w") as f:
        for class_id, bbox in zip(transformed['class_ids'], transformed['bboxes']):
            f.write(f"{class_id} {' '.join(map(str, bbox))}\n")
```



## 5. 数据集验证脚本

 创建验证脚本确保数据正确性： 

```
# data/verify_dataset.py
import cv2
from pathlib import Path

def verify_dataset():
    for img_path in Path("data/dataset/images/train").glob("*.png"):
        image = cv2.imread(str(img_path))
        label_path = Path("data/dataset/labels/train") / f"{img_path.stem}.txt"
        
        if not label_path.exists():
            print(f"Missing label for {img_path.name}")
            continue
            
        with open(label_path) as f:
            for line in f:
                class_id, xc, yc, w, h = map(float, line.split())
                # 转换为像素坐标
                x1 = int((xc - w/2) * image.shape[1])
                y1 = int((yc - h/2) * image.shape[0])
                x2 = int((xc + w/2) * image.shape[1])
                y2 = int((yc + h/2) * image.shape[0])
                
                # 绘制检测框
                cv2.rectangle(image, (x1, y1), (x2, y2), (0,255,0), 2)
        
        cv2.imshow("Verify", image)
        if cv2.waitKey(100) == ord('q'):
            break

if __name__ == "__main__":
    verify_dataset()
```

## 6. 数据集划分建议

 使用脚本自动划分训练集和验证集： 

```
# data/split_dataset.py
import shutil
from pathlib import Path
import random

def split_dataset(train_ratio=0.8):
    image_files = list(Path("data/dataset/images/all").glob("*.png"))
    random.shuffle(image_files)
    
    split_idx = int(len(image_files) * train_ratio)
    train_files = image_files[:split_idx]
    val_files = image_files[split_idx:]
    
    # 创建目录
    Path("data/dataset/images/train").mkdir(parents=True, exist_ok=True)
    Path("data/dataset/images/val").mkdir(parents=True, exist_ok=True)
    Path("data/dataset/labels/train").mkdir(parents=True, exist_ok=True)
    Path("data/dataset/labels/val").mkdir(parents=True, exist_ok=True)
    
    # 复制文件
    for file in train_files:
        shutil.copy(file, f"data/dataset/images/train/{file.name}")
        label = file.with_suffix('.txt')
        if label.exists():
            shutil.copy(label, f"data/dataset/labels/train/{label.name}")
    
    for file in val_files:
        shutil.copy(file, f"data/dataset/images/val/{file.name}")
        label = file.with_suffix('.txt')
        if label.exists():
            shutil.copy(label, f"data/dataset/labels/val/{label.name}")

if __name__ == "__main__":
    split_dataset()
```



## 关键注意事项

1. **标注一致性**：
   - 相同类别的目标在不同图像中应保持相同class_id
   - 使用`game_data.yaml`中的类别顺序
2. **数据平衡**：
   - 每个类别至少应有200-300个样本
   - 对小目标可适当增加样本
3. **标注质量检查**：
   - 确保边界框紧贴目标边缘
   - 避免遗漏目标或包含过多背景
4. **游戏特定考虑**：
   - 包含不同视角、距离的目标
   - 覆盖各种游戏场景(白天/夜晚、不同地图等)

## 帧提取策略推荐

### 1. 基础推荐方案

bash

复制

```
# 每秒提取4-6帧（适用于大多数游戏场景）
ffmpeg -i gameplay.mp4 -r 6 data/train/frame_%04d.png
```

### 2. 不同场景下的优化方案

| 场景类型      | 推荐帧率 | 参数示例 | 适用情况说明       |
| :------------ | :------- | :------- | :----------------- |
| 快速动作场景  | 8-10fps  | `-r 10`  | 格斗/FPS等高速游戏 |
| 一般RPG/MMO   | 4-6fps   | `-r 5`   | 大多数3D游戏       |
| 策略/静态场景 | 2-3fps   | `-r 3`   | 卡牌/战棋类游戏    |
| 过场动画      | 1fps     | `-r 1`   | 剧情动画等线性内容 |

### 3. 高级智能提取方案（推荐）

bash

复制

```
# 基于场景变化的动态提取（需要较新版本FFmpeg）
ffmpeg -i gameplay.mp4 -vf "select=gt(scene\,0.02)" -vsync vfr data/train/frame_%04d.png
```

- `scene=0.02` 表示场景变化阈值（0-1）
- 此方法会在画面有显著变化时才保存帧

## 专业建议补充

1. **数据多样性优先**：

   bash

   复制

   ```
   # 每10秒提取1秒的完整60帧（获取连续动作）
   ffmpeg -i gameplay.mp4 -vf "fps=60,select=not(mod(n\,600))" -vsync 0 data/train/frame_%04d.png
   ```

2. **多分辨率处理**：

   bash

   复制

   ```
   # 同时生成缩略图（用于小目标检测）
   ffmpeg -i gameplay.mp4 -r 5 -vf "scale=iw/2:ih/2" data/train/small_%04d.png
   ```

3. **内存优化方案**（处理4K视频时）：

   bash

   复制

   ```
   ffmpeg -i 4k_gameplay.mp4 -r 5 -vf "scale=1920:-1" -pix_fmt yuv420p data/train/frame_%04d.png
   ```

## 注意事项

1. 训练数据量建议：

   - 每个类别至少500-1000个样本
   - 目标在帧中的出现频率比帧总数更重要

2. 硬盘空间预估：

   复制

   ```
   1080p截图：约1.5MB/帧
   1小时视频@5fps → 5×3600=18,000帧 → ~27GB
   ```

3. 性能平衡公式：

   复制

   ```
   最优帧率 ≈ log(游戏原生FPS) × 动态系数
   (动态系数：动作游戏取1.5-2.0，策略游戏取0.5-1.0)
   ```